/*
 * generated by Xtext 2.10.0
 */
package com.regnosys.rosetta.generator.java.function

import com.google.inject.Inject
import com.regnosys.rosetta.tests.util.ModelHelper
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import com.regnosys.rosetta.tests.RosettaInjectorProvider
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import com.regnosys.rosetta.rosetta.RosettaFunction
import com.regnosys.rosetta.rosetta.RosettaPackage
import org.junit.jupiter.api.Disabled

@ExtendWith(InjectionExtension)
@InjectWith(RosettaInjectorProvider)
class RosettaFunctionParsingTest {

	@Inject extension ModelHelper
	@Inject extension ValidationTestHelper 
	
	@Test
	def void shouldParseMandatoryFields() {
		'''
			spec FunctionName :
				output: 
					outputName string (1..1)
		'''.parseRosettaWithNoErrors
	}
	
	@Test
	def void shouldReferToInputsFromPreCondition() {
		'''
			spec Add <"A function that adds two numbers"> :
				inputs:
					input1 number (1..1)
					input2 number (1..1)
					
				output: 
					output1 number (1..1)
			
				pre-condition <"Input numbers are not the same">:
					input1 <> input2;
		'''.parseRosettaWithNoErrors
	}
	
	@Test
	def void shouldRequireAtLeastOneInputWhenDefined() {
		'''
			spec Add <"A function that adds two numbers"> :
				inputs:
					
				output: 
					output1 number (1..1)
		'''.parseRosetta.assertError(RosettaPackage.Literals.ROSETTA_FUNCTION, "org.eclipse.xtext.diagnostics.Diagnostic.Syntax")
	}
	
	@Test
	def void shouldAllowReferenceToOtherFunctions() {
		'''
			spec One:
				output:
					output1 number (1..1)
					
			spec Two:
				output:
					output1 number (1..1)
				
				post-condition:
					output1 = One();
		'''.parseRosettaWithNoErrors
	}
	
	@Test
	def void shouldAllowFunctionArguments() {
		'''
			spec One:
				inputs:
					input1 number (1..1)
					
				output:
					output1 number (1..1)

			spec Two:
				output:
					output1 number (1..1)
				
				post-condition:
					output1 = One(1);
		'''.parseRosettaWithNoErrors
	}
	
	@Test
	def void supportExistsOperator() {
		'''
			spec Two:
				output:
					output1 number (1..1)
				
				post-condition:
					output1 exists;
		'''.parseRosettaWithNoErrors
	}
	
	@Test 
	def void shouldParseWhenMultipleExpressionsInConditionBlock() {
		'''
			spec Two:
				inputs:
					input1 number (1..1)
				output:
					output1 number (1..1)
				
				post-condition:
					output1 exists;
					input1 = output1;
		'''.parseRosettaWithNoErrors
	}
	
	@Test
	def void shouldSupportExistsExpression() {
		'''
			spec Two:
				inputs:
					input1 number (1..1)
				output:
					output1 number (1..1)
				
				post-condition:
					if output1 exists then 1 else 0;
		'''.parseRosettaWithNoErrors
	}
	
	// Validation test
	@Test
	def void shouldValidateFunctionArgumentSize() {
		'''
			spec One:
				inputs:
					input1 number (1..1)
					
				output:
					output1 number (1..1)

			spec Two:
				output:
					output1 number (1..1)
				
				post-condition:
					output1 = One(1, 2);
		'''.parseRosetta.assertError(RosettaPackage.Literals.ROSETTA_CALLABLE_WITH_ARGS_CALL, "")
			
	}
	
	@Test
	def void shouldErrorRecurrsion() {
	}
	
	@Test
	def void shouldNotReferenceOutputsOnPreConditions() {
		// Should this be a content assist test?	
	}
	
	
}
